## `tcp` 与 `udp` 区别
* 具体的使用场景（拥塞控制等）
* `TCP NODELAY`怎么实现
* `TCP、UDP`的内部数据结构
* `udp`的改造
    * 怎么让 `udp`实现可靠传输

* 长连接怎么实现的
    * 首先在建立连接的时候
    
        * 在`HTTP`响应头和`HTTP`请求头中都有`Connection: Keep-Alive`参数，用于表示建立长连接
        
        * 客户端和服务端发现这个参数之后都不会关闭这个连接
        * 实现的原理：
            * 通常的做法是，在服务器的程序中加入一个死循环，在循环中监测数据的变动
            
            * 客户端实现的就是用一种普通轮询的结果
            
            * 当发现新数据时，立即将其输出给浏览器并断开连接，浏览器在收到数据后，再次发起请求以进入下一个周期，这就是常说的长轮询`（long-polling）`方式
    * 基于`Jetty Continuation`实现的长连接 
        * 长轮询
        * `HTTP`请求被暂时挂起，当挂起超时或非同步的事件发生时，被挂起的`HTTP`请求可以被重新恢复
    * 基于`Servlet3`实现的长连接
        * `Servlet3`可以实现一旦请求被服务端接受就不再关闭连接,直到超时事件发生才重新建立新的连接
        
        * 连接不会一直占用线程
        * 不需要**客户端询问**是否准备好 




