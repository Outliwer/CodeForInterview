## 类加载机制
* 被不同类加载器加载出来的对象的`Class`对象` == `操作，返回结果
    * 只有同一个类加载器加载的类才是相等的 

* 什么时候需要打破**双亲委派模型**
    * 什么是**双亲委派模型**
        * 分类
            * 启动类加载器
            * 拓展类加载器
            
            * 应用程序类加载器
        * 加载类的过程
            * 一个类加载器收到类加载请求
            * 将请求**委派**给父类加载器完成：最终会到最顶层的启动类加载器
            
            * 只有父加载器反馈**无法完成**这个加载请求，子加载器才会尝试自己去加载  
        *   好处
            * 保证同一个路径的类是唯一的
        * 破坏
            * 未使用**双亲委派模型**之前
                * 使用`findClass()`方法进行兼容 
                
            * `JNDI`服务    
                * 线程上下文加载器
                
                    * 可以通过该加载器父加载器去加载子加载器的`SPI`代码 
            * 模块热部署
                * 网状结构 
                    
                    * 可以在平级类加载器中进行加载 
                        * 将`Import` 列表中的类委派给`Export`这个类的`Bundle`的类加载器加载
                        
                        * 寻找当前`Bundle`的`ClassPath`，用自己的类加载器进行加载
                        * 委派给`Fragment Bundle`的类加载器加载
                        
                        * 委派给`Dynamic Import`列表中的`Bundle`进行加载
* 过程
    * 加载
    
        * 通过一个**类的全限定名**来获取定义此类的二进制字节流 
        * 转化为方法区的运行时**数据结构**
        
        * 在内存中生成一个代表该类的`java.lang.Class`对象，作为各种数据的访问入口
        * 方式
            * 动态代理：使用`generateProxyClass`来为特定接口生成代理类的二进制的字节流
            
            * `JSP`应用 ： 通过`JSP`生成`Class`类
            * 从网络、`ZIP`等存储文件中读取
    * 验证
    
        * 文件格式验证
            * 词法分析 
        * 元数据验证
            * 语义分析 
        * 字节码验证
            * 上一个过程只是验证语义是**正确**的，这个过程确定语义是否是**符合逻辑**的，保证不会在运行过程中出现危害虚拟机的情况
            
        * 符号引用验证 
            * 将符号引用转化为直接引用：
            * 对类**本身以外**的信息（**常量池**中的各种符号引用）进行匹配性的校验 
    * 准备
    * 解析
        * 符号引用转化为直接引用的过程
        * 主要有：
            * 类或接口的解析
            * 字段解析
            * 类方法解析
            * 接口方法解析  
    * 初始化
        * 执行类构造器`<client>()`的过程
            * 自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
            * 虚拟机会保证子类 `<client>()`执行前父类`<client>()`已经执行完
        * 出现了`new、getstatic、putstatic、invokestatic`等关键字的时候，需要进行初始化使用
        
            * 使用`new`关键字
            * 读取或设置一个类的静态字段
            * 调用一个类的静态方法时
        *  对类进行反射调用时
        *  初始化一个类发现父类未进行初始化时
        *  当虚拟机启动时，初始使用静态`main`的那个类会先初始化
        *  动态语言支持时：如果`java.lang.invoke.MethodHandle`实例最后解析的结果是`REF_getStatic、REF_putStatic、REF_invokeStatic`的方法句柄，且对应类没有初始化
    * 使用
        * 栈帧
            * 局部变量表
            * 操作数栈
            * 动态连接
            * 方法返回地址 
        *  
    * 卸载


* 符号引用与直接引用
    * 直接引用和**虚拟机的布局**是相关的，不同的虚拟机对于相同的符号引用所翻译出来的直接引用一般是不同的。如果有了直接引用，那么直接引用的目标一定被加载到了内存中 
    
    * 符号引用可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可，符号引用和**虚拟机的布局**无关。

