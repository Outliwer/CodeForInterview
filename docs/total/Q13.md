## 头条面试（后台方向）

* 一个进程，有`10`个子进程，那么一个子进程`fork`一个子进程，那么这个子进程有多少个进程   
    *  该函数被调用一次，但返回两次。两次分别返回父进程和子进程。子进程的返回的是`0`（内核代码中设定的为`0`），而父进程返回的是子进程的进程`PID`。父进程和子进程共享代码段，但是分别拥有自己的数据段和堆栈段。
  
* 物理地址和虚拟地址
    * 逻辑地址 **=>**（段表）**=>** 线性地址 **=>** （页表）**=>** 物理地址
    * 物理内存：
        
        * 当前内存条的限制
            * `16`位可以寻址`20`位地址 
        * 内存单位：页帧
        
    * 虚拟内存 
        * 内存单位：页
        * `CPU`的地址线可以直接进行寻址的内存空间大小 
    * 页表
        * 映射虚拟内存页到物理内存页的
        
        * 页面失效`（page fault）`功能。操作系统找到一个最少使用的页帧，让他失效，并把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，这样就保证所有的页都有被调度的可能了
        * 偏移量 + 页号
    * 段表 
        * 偏移量 + 段号
        * 只能相对程序入口的首地址的偏移量来定位
        * 每个段的基地址对应线性地址都是为`0`，而且都可以使用`4G`的地址空间
* `http`传入的`Request`和返回的`Response`
    * `Request`
        * 请求行：版本、方法、地址
        * 请求头：
        * 一个空行
        * 正文 
    * `Response`
        * 响应行：状态描述
        * 响应头
        * 一个空行
        * 正文
* `503`和`500`区别。`301`和`302`区别
    * 服务器状态`502 503 504`什么问题 
        * `500` 表示服务器的资源发送错误
        
        * `501` 服务器还是不具有请求功能的
        * `502` 这是服务器上的一个错误网关
        * `503` 服务不可用
        * `504` 网关超时
    * 服务器状态`301 302`什么问题 
        *  `301`是永久重定向
        
        *  `302`是临时重定向
* `http close-wait`状态
    *  `time-wait`
    
        * 等待`2MSL` ： `30s、1min`等  
    * 三次握手
        * 客户端的`TCP`首先向服务器端的`TCP`发送一个特殊的`TCP`报文段
            * `SYN = 1, seq = client_isn` 
        
        * 包含`TCP SYN`报文段的`IP`数据到达服务器主机，服务器会从该数据报中提取出`TCP SYN`报文段，为`TCP`连接分配`TCP`缓存和变量，并向客户`TCP`发送允许连接的报文段
            * `SYN = 1, seq = server_isn,ack = client_isn + 1`  
        
        * 收到 `SYNACK`报文以后，客户也要给该连接分配缓存和变量，并发送报文表示允许连接以及确认
            *  `SYN = 0, seq = client_isn + 1,ack = server_isn + 1`   
    * 四次挥手 
        * 客户`TCP`发送`FIN`比特置为`1`的`TCP`报文段
        * 先发送`ACK`表示接收到`FIN`
        
        * 等数据传输完成后发送`FIN`
        * 发送`ACK`表示接受到`FIN`
* 滑动窗口和`TCP`流量控制
    * `tcp`接收窗口和拥塞窗口 
        * 为什么要拥塞控制？
            * 路由器缓存溢出会导致丢包问题  
    
    * 假设`tts`（数据从两端一来一回）` 100ms`，那么从输入一个`http://url`到得到网页要多少时间
        * `200ms`
        * 估计往返时间是 `1/8` 的比重
    
    * `https`呢？
        * 即`HTTP`下加入`SSL`层，`HTTPS`的安全基础是`SSL`，因此加密的详细内容就需要`SSL`
        
        * 需要证书
        * 不是明文加密
        * 端口为`443`而不是默认端口 
        * 过程增加
            * 在三次握手以后
            * 将`CA`证书返回给客户端 
            * 客户端根据浏览器内内置的`C.pub`验证`CA`证书的合法性
            * 客户端生成随机对称秘钥
            * 将堆成秘钥通过`S.pub`加密发送给客户端
            * 通过秘钥进行通信
        * 对称加密和非对称加密
            * 基于非对称加密（`CA的pub`）的对称加密 
    * 连续发送两次`http`请求，会得到两次结果吗？可能第二次比第一次快吗？
        * 会，可能存在长连接 
    * `TCP`包头阻塞
        * 先收四个字节，判断是不是合法的包头，如果是，解析包体的长度，然后接收；如果不是合法的包头，关闭连接或继续接收下四个字节
    * `ack`什么时候发送，丢失了会怎么样
        * 发送包的时候发送，丢失会进行重传
    * `sack`了解吗
        * 它使得接收方能告诉发送方哪些报文段**丢失**，哪些报文段**重传**了，哪些报文段已经提前收到等信息。根据这些信息`TCP`就可以只重传哪些真正丢失的报文段。 
    * 重传`ack`的时机只有`ack`超时吗
        * 快速重传（可以再划分累积`ACK`重传和不累计）
            * 发送方只要一连接受到三个重复确认，就会快速重传
            
        * 超时重传 
            * 超时计数器
            * 在滑动窗口允许发送为`0`的时候，停止发送
    * 拥塞窗口要不要把自己的大小发给接收方，意义何在
        * 需要
        * 发送方只会发送这么多的上限，可以减少接收方的窗口大小
    * `TCP`缓存
        *  存储窗口的数据
        
        *  准备发送的数据和未确认已发送数据
        *  未按序到达的数据和未被应用程序读取的数据
    * 保证
        * 数据合理分片和排序
        * 确认与重传
        * 拥塞控制
        * 流量控制
        * 数据校验
           
    * `http`缓存机制 
        * 对请求的静态文件进行缓存
        * 浏览器存在一个缓存数据库,用于存储缓存信息,在第一次从服务器返回以后记录缓存
        * 缓存分类
            * 强制缓存
                * 在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略 
            * 比较缓存  
                * 将缓存信息中的`Etag`和`Last-Modified`通过请求发送给服务器，由服务器校验，返回`304`状态码（未发生改变）时，浏览器直接使用缓存 
    * 长连接怎么实现
    
        * 在`HTTP`响应和请求的请求头中：`Connection: Keep-Alive`
        * `Jetty6`
        * 基于`Servlet`的实现
    * 延迟`ACK`的意义在哪
        * 不用单独发送造成开销
        * 可以一次 `ACK` 进行多次确认
        * 避免**糊涂窗口综合症**
        
            * 对于接收端来讲，如果接收很慢，一次接收`1`个字节或者几个字节，这个时候接收端缓冲区很快就会被填满，然后窗口通告为`0`字节，这个时候发送端停止发送，
            * 应用程序收上去`1`个字节后，发出窗口通告为`1`字节，发送方收到通告之后，发出`1`个字节的数据，这样周而复始，传输效率会非常低
             
    * 为什么不能每次都直接发大的窗口
        * 存在还没有发送的数据
        * 造成浪费 
    * `http`协议怎么解析的，是文本协议还是二进制协议
        * 是文本协议
        * 自己通过的**流获取**的方式解析 
        
    * `http`请求的报文头部是什么
        * 包含哪几种协议，怎么保证幂等性 
        * `GET、DELETE、PUT、POST`四种主要方法


* 如果滑动窗口为`0`，则怎么办
    * 这时发送端就不发数据了，但发送端会发`ZWP`（即`Zero Window Probe`技术）的包给接收方，让接收方回`ack`更新`Window`尺寸 
* `buffer`和`cacahe`区别
    * `cache`改善系统性能的主要原因是数据访问的局部性 
    * `buffer`改善系统性能的主要原因是减少不必要的状态切换和设备`I/O`
    * `cache`通常是硬件或`OS`提供，用户程序不需要
    * `buffer`更多的是共同定义
    

* 一个上`T`的文本文件，里面很多字符串并且用空格分隔，找到**不同**的字符串数量
* 手写代码：**全排列**
* 非递归**中序遍历**二叉树
* 如何处理`get`和`post`
    * 先发`post的header`，返回一个`100`继续，就等待一个`tcp的ack`，然后再发剩下的包
     
    * `get`是从服务器上获取数据，`post`是向服务器传送数据
    * 因此`post`不是幂等的
    * `get`方式提交的数据最多只能有`1024`字节，而`post`则没有此限制（也可以用请求行、请求头、正文的格式来解答）
    * 对于`get`方式，服务器端用`Request.QueryString`获取变量的值，对于`post`方式，服务器端用`Request.Form`获取提交的数据
* 一些`linux`语句的作用
* 同步和异步
    * 调用者不能立刻得到结果，通过回调得知
    * 进程主动获取
* `linuxIO`模型，区别在哪
    * `IO`的读取一直会分为两个阶段
        * 等待数据准备
        * 将数据从内核拷贝到进程中
        * 对于`socket` 流而言
            * 通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区
            * 将数据从内核缓冲区复制到应用缓冲区 
            * https://www.jianshu.com/p/486b0965c296
    * `BIO`
        * 最简单的模型
        * 阻塞其他任务 
            * 从数据等待到数据拷贝两个过程都是阻塞的 
    * `NIO`
        * 采用同步非阻塞 `IO`，通过轮询的方式
        * 而拷贝数据的过程仍然处于阻塞状态
            * 在数据等待过程中，将整个过程分成了**多个模块**，只有在数据完成准备以后开始进行拷贝，会降低**吞吐量**（也就是整个流程**会拉长**）
    * 多路复用`I/O`（**同步**（进程**主动**获取）非阻塞）
        * 循环查询**多个任务**的完成状态，只要有**任何一个任务**完成，就去处理
        * `select、poll、epoll`
        * 优势在于：单个线程可以处理多个`I/O`，可以处理更多的`I/O`
        * 实际上，第一个部分可以是阻塞的，也可以是非阻塞的
    * 信号驱动`I/O`
        * 允许`Socket`进行信号驱动`IO`,并安装一个信号处理函数 
        * 当数据准备好以后，进程会收到一个`SIGIO`信号
        * 可以在信号处理函数中调用`I/O`操作函数处理数据
    * 异步非阻塞 `I/O`（`AIO`）
        *  `I/O`两个阶段都是非阻塞的
        *  数据的拷贝由**内核**完成，因此不是顺序执行的，在调用该方式以后直接返回给**用户态**
        *  当数据准备完成以后，将会直接发送**信号**到进程中
            * 用户态时会进行一个类似**中断**
            * 内核态时会**阻塞**一会
            * 被挂起以后会**唤醒**进程  
            
        ![](https://lh3.googleusercontent.com/-MHPokp4B6GI/W6IkENem4tI/AAAAAAAAAAs/pDt1UUm2YOQtSht-2knLGNPylacwvEiugCHMYCw/I/15373527080545.png)

* 线程独立拥有哪些资源
    * 栈
    * 寄存器
    * 状态
    * 程序计数器 
    * 进程独立占用的
        * 地址空间
        * 全局变量
        * 打开的文件
        * 子进程
        * 信号量
        * 账号信息
    * 线程共享
        * 正文段
        * 数据段
            * 包含全局变量和静态变量 
        * 堆   
        * 文件描述符
        * 信号的处理器
        * 进程的当前目录和进程用户`ID`与进程组`ID`
    * 线程与进程差别
        * 通信
        * 调度与切换
        * 共享资源
    * 进程的优势
        * 更强的容错性
        * 更好的多核可伸缩性    
* `nginx`怎么处理请求
    * 负载均衡怎么做

* `interrupt`与`signal`有什么差别
    * 中断有优先级，信号没有优先级
    * 信号处理程序在用户态，而中断处理程序在核心态下
    * 中断响应是及时的，而信号响应都有较大的延迟
    * 相同点
        * 采用了相同的异步通信方式
        * 当检测出有信号或中断请求时，都暂停正在执行的程序去执行相应的处理程序
        * 会回到原来的断点
        * 都可以进行屏蔽  
* `LRU`怎么实现
* `64`匹马，决出前`4`匹最快的
* `epoll`相关问题
    *  一旦某个文件描述符就绪，就可以通知程序进行相应的读写操作，这个时候相当于第二步会进行阻塞
        *  区别所在
            *  而`epoll`在“醒着”的时候只要判断一下就绪链表是否为空就行了，`select`要进行遍历
            *  在调用复制到内核时，`epoll`对于`current`当前线程只进行一次复制而`select`要进行遍历
    *  `select`
        * 每一次调用 `select`都会将`fd`集合从用户态拷贝到内核态，造成了开销（**三个位图**）
        * 每一次调用都需要在内核遍历传递进来的所有`fd`
        * 支持的文件描述符过小，默认是`1024`

            
    *  `poll`
        * 描述集合的方式不同，使用的是`pollfd`结构（**指针**）
    *  `epoll`
        * `epoll`的解决方案在`epoll_ctl`函数中。每次注册新的事件到`epoll`句柄中时
        
        * 不是每一次将`current`轮流加入`fd`对应的设备等待队列中，而只在`epoll_ctl`时把`current`加载一次，`epoll_wait`的工作实际上就是在这个就绪链表中查看有没有就绪的`fd`
        * 支持的`fd`上限是最大可以打开文件的上限
        * 工作模式
            * `LT`模式
            
                * 内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的`fd`进行`IO`操作 ，没有操作的话仍然会通知
                * 因此可以是阻塞类型和非阻塞类型任意
            * `ET`模式 
            
                * 减少了`epoll`事件被重复触发的次数
                * 在文件从未就绪变为就绪以后将通知，仅一次，因此只能是非阻塞类似
* 两个升序数组，找出第`k`小的数字
* `Spring`相关
    * `IOC`概念 
    *  热加载功能的`IOC`容器
    *  `AOP`原理
    * `Bean`的默认作用范围是什么以及其他的作用范围
    
        * `singleton`（**默认**）
        * `prototype`
        * `request`
        * `session`
        * `globalsession`
* `MySql`其他的索引 
* `ConcurrentHashMap`详细介绍
    * `JDK7` 和 `JDK8`的区别 
    * `JDK8`
        * 基于`CAS`实现 
        * 链表长度超过一定长度转化为红黑树
        * 使用`HashEntry`保存数据，`table`数组元素作为锁，实现对每一行的加锁
        
* `Java bin`包下面的工具
    * 基本工具
        * 编译器
        * 应用程序启动器
        * 启动工具
        * 压缩打包工具
        * 调试器 
    * 安全工具
        * 管理密钥库和证书
    * 国际化工具
        * 可本地化应用 
    * 远程调用工具
        * 远程对象注册表
        * 生成远程对象
    * 部署工具
        * 进行打包 
    * `Web`工具
        * `web` 启动命令行工具
    * 检测工具
        * `jhat`、`jmap`  
* 红蓝两种球，总共`N`个，` N>2`, 排列组合，连续`3`个颜色一样是非法的，求合法的排列数量
* `DNS`的**究极细节**
    * 见`DNS`解析 
* `ThreadLocal？`应用场景？
    * 见多线程 
* `Web`容器用的什么？你项目里涉及了`SSM`框架，一个请求到`Tomcat`容器了，怎么到`SSM`代码中去？
* 算法题：`n`个长为`n`的有序数组，求最大的`n`个数
* 如果让你设计一个下载器中的断点续传功能，你打算怎么设计，会有哪些问题
* 有一个袋子里面装了黑白两种颜色的球若干个，现在每次从袋子里面摸两个球，如果摸到的是相同颜色的球那么将两个球丢弃并且重新放一个黑球进去，如果摸到的是不同颜色的球则将黑球白球放回，问最后袋子里面存在哪些情况并且详细说明过程，推导方法
*  有一台服务器，含有若干的`CPU`和内存资源，现在有一系列规格不等的虚拟机，设计算法最大化的利用服务器的资源并分析求解的复杂度
*  手撕代码，给一个数组，将数组看做二叉树，输出二叉树的右半边部分，每一层要求逆序输出，开始使用层序遍历，面试官后来问了有没有更好的解法
*  最长公共子串
*  四次挥手，会出现哪些问题，如果过程中服务器宕机会出现什么问题
    *  客户端死机
        * `TCP`还设有一个保活计时器 
        * 服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为`2`小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送`10`个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接 
        
    * 服务器进程所在的主机宕机后重启
        * 重启以后所在主机`TCP`丢失了崩溃前所有连接信息，即`TCP`收到了一个根本不存在的连接，会返回一个`RST`
         
        * 可以从代码层面上进行其他服务器层面的连接
    * `Server`进程所在的主机宕机
    
        * 端`TCP`持续重传分节，试图从服务器上接收一个`ACK`，然而服务器始终不能应答，重传数次之后，大约`4~10`分钟才停止，之后返回一个`ETIMEDOUT`错误 
        
    * `Server`进程所在的主机关机
        * 发送`SIGTERM`信号，和杀死`Server`的情况一样
                
    * 试图与一个不存在的端口建立连接
        * 服务器返回一个`RST`。放弃这次连接的建立，并且返回给应用程序一个错误
    * 试图与一个不存在的主机上面的某端口建立连接（**服务器宕机**）
        * 如果客户端`TCP`没有得到任何响应，那么等待`6s`之后再发一个`SYN`，若无响应则等待`24s`再发一个，若总共等待了`75s`后仍未收到响应就会返回`ETIMEDOUT`错误
    * `Server`进程被阻塞
    
        * **永远**不会返回结果 
    * 主动杀死`Server`
        * 这相当于服务器端来主动关闭连接 `——` 会发送一个`FIN`分节给客户端`TCP`
        * `TCP`会自动响应一个`ACK`，然后调用`close`函数，会开始四次挥手
 
*  设计一个`HashMap`类，键值类型都是整形，唯一的要求就是尽可能高的提高内存的利用率，存放尽可能多的键值对，问了`Java`中的`hashmap`，会有哪些问题
*  操作系统堆和栈的区别
    * 内存分配
        * 堆由程序员分配
        * 栈是自动分配的
    * 申请方式
        *  前者需要指定大小
    * 系统响应
        * 会有记录空闲地址的链表，进行空间分配
        * 直接分配即可 
    * 存放内存
        * 堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排
        * 函数调用时指令，参数这些进行入栈 
    * 大小限制
        * 有效的虚拟内存
        * 栈的最大容量已经确定 
    * 存取效率  
        * 编译时确定，效率比较慢
        * 运行时确定，效率比较快 
*  进程调度算法
    * 先来先服务
    * 短作业优先
    * 高优先权优先调度算法
        * 非抢占式优先权算法
        * 抢占式优先权调度算法
        * 高响应比
         
    * 基于时间轮转片的调度   
        * 多级反馈队列调度算法
            * 开始放于第一优先级
            * 注意优先级越高实际时间片越少，但是执行优先
              
*  `Java`中的`Condition`类是用来干什么的
    * 替代`Object`的`wait()、notify()`实现线程间的协作     
    * `Condition`中的`await()`对应`Object`的`wait()`
    * `Condition`中的`signal()`对应`Object`的`notify()`
    * `Condition`中的`signalAll()`对应`Object`的`notifyAll()`
*  设计一个线程池
*  无序数组的中位数
*  无序数组第k大的一个数（**快排**）
*  `Linux`有哪些进程通信方式
    *   管道（`pipe`）
    
        * 单向流动：`s_pipe`
        * 只能在亲缘之间：`name_pipe`
    *   信号
        * 通知接受进程有某种事件发生
          
    *   消息队列
        *    消息的链表，存放在内核中并由消息队列标识符标识
        *    解决了信号传递消息少
        *    管道只能承载无格式字节流以及缓冲区大小受限
    *   共享内存
        *    
    *   信号量
        * 控制多个进程对共享资源的访问   
    *   套接字
        * 可以用于不同机器之间的进程通信   
    * 关于线程之间的通信
        * 锁机制
        * 信号量
        * 信号 
*  `Linux`共享内存
    *   不同进程之间共享的内存通常安排为同一段物理内存
    *   没有提供同步机制，可能存在不同步问题，**因此**需要其他的通信方式辅助
    *   `shmget`函数用于创建共享内存（会进行命名），`shmat`函数用来启动对共享内存的启动



*  `chm`和`countdownlatch`
    * 一个线程等待多个线程
    * 可以使用`countdownlatch`和`cyclicBarrier`来实现
    * `countdownlatch`能够使一个线程等待其他线程完成各自的工后再执行，计数值`（count）`实际上就是闭锁需要等待的线程数量
    *  `cyclicBarrier` 可以让一组线程达到一个屏障时被阻塞，直到最后一个线程达到屏障时，所以被阻塞的线程才能继续执行
*  `Java`的集合类哪些是线程安全
    *  `List`
        * 继承自`Collection`接口
        * `vector`相当于`ArrayList`的线程安全类  
        * `stack` 
        * `Queue`可以分为阻塞队列和非阻塞队列
            * `ConcurrentLinkedQueue` 
            * `LinkedBlockingQueue`
    *  `Map`
        * `Map`类型者，持有` key-value pair`，像个小型数据库
        * `hashtable`：就比`hashmap`多了个线程安全 
        * `chm`
    *  `Set`
        * 继承自`Collection`接口  
        * `ConcurrentSkipListSet`
            * 对于`TreeSet`、`LinkedSet`都不是线程安全的 
        * `enumeration` 相当于迭代器
    * 遍历方式：
        * 迭代器和`Entry`  

*  `Redis`
    * 持久化：追加日志和备份文件
        * 快照
            * 使用`SAVE`和`BGSAVE`
            * `fork and cow ` 使用的共享内存
            * 子进程完成写`RDB`文件，用新文件替代老文件
        * `AOF`
            * 使用的是追加日志的方式 
            * 定时`sync`，最多丢失`1s`的数据
        * 重启的时候
            * 先使用`RDB`文件，然后使用`AOF`对近期的数据进行恢复
        * 虚拟内存方式 
    * 与`memcached`比较的优势
        * 速度快
        * 更加丰富的数据存储
        * 可以持久化
        * 底层模型：`Redis`自己实现了`VM`机制 
    * 优点
        * 速度快
            * 单线程不用切换
            * 分成了文本事件和时间事件
            * 分路复用`I/O`
            * 只从内存中进行读取
    * 缺点
        * 一致性
            * 补偿机制 
        * 缓存雪崩
            * 双缓冲，用另外一个缓存来替代数据库
            * 互斥锁
            * 失效时间的随机设置 
        * 缓存穿透
            * 使用互斥锁访问数据库
            * 采用异步更新
                * 先返回
                * 缓存不存在异步读取数据库进行更新 
            * 使用布隆过滤器进行过滤判断`key`是否合法 
        * 缓存的并发竞争 
            * 分布式的多集群出现多个`set`的情况 
            * `Redis`客户端对`Redis`进行并发访问会出现问题
            * 使用`Redis`锁
        * 不能做海量数据的存储 
        * 对于多核`CPU`无法保证性能
    * 怎么保证热点数据
        *  内存数据集上升到一定大小会有缓存淘汰策略
    * 底层实现 
        * 读写分离 `Reactor` 模式 
    * 异步队列
        * 一般使用`list`结构作为队列，`rpush`生产消息，`lpop`消费消息   
        * 延时队列
            * 使用`sortedset`，拿时间戳作为`score` 
            * 消息内容作为`key`调用`zadd`来生产消息，消费者用`zrangebyscore`指令获取`N`秒之前的数据轮询进行处理
    * `Redis`哨兵
        *  本质是一个运行在特殊模式下的`Redis`服务器
        *  初始化
        *  进行`Sentinel`代码的替换
        *  初始化状态
        *  监视主服务器列表
    * 淘汰机制
        * 定期删除和惰性删除 
        * 内存淘汰策略
            * 当内存不足时，新写入报错
            * 当内存不足时，移除最近最少使用的`key` 
            * 随机移除
            * 另外就在设置了过期时间中随机或者移除最近最少使用
            
    *  `Redis`的几个数据结构
        * `String` 
            * 整数和字符串  
        * `hash`
            * 字典
            * 压缩列表
             
        * `list`
            * 压缩列表
            * 双端链表
             
        * `set`
            * 字典
            * 整数集合 
        * `sorted set`
            * 压缩列表
            * 跳跃表 
        * 内部使用而言
            * 整数
            * 字符串
            * 双端链表
            * 跳跃表
                * `list`和节点实现 
            * 压缩列表
            * 字典
                * `hashTable` 
            * 整数集合 
    * 如果`Redis`有`1`亿个`key`，使用`keys`命令是否会影响线上服务
    
        * 对于`CPU`的使用率会很高 
        * 将要使用的`key`存储到`set`里面
    * `Redis`集群搭建
        * `redis cluster `
        * `redis sentinel`
    * 添加一个节点如何分配槽
        * `CLUSTER MEET `
        * `CLUSTER ADDSLOTS`
    * 迁移`slot`的过程中，我`get`或者`set`怎么办
        * 是否正在迁移
        * 迁移返回`ASK`错误，进行另外节点的查询
    * `Redis` `10W`的`QPS`瓶颈点在哪里
        * 受限网卡带宽（网络`I/O`）瓶颈 
        * `CPU`竞争（是`CPU`密集型应用）
        * 出现**阻塞**
            * `fork`阻塞
            * `aof`阻塞：因为设置的原因
    * `redis`的总体结构
        * 读写分离
            *  `epoll`的非阻塞多路复用特性
        * 异步化组件
            * 比如`bgSave`来持久化 
        
    * 怎么实现主从复制的
    * `redis`的事件分发
        * 文本事件
            * 读事件
            * 写事件 
        * 时间事件（`serverCron`函数）
            * 周期事件
            * 定时事件
            * 平均每间隔`100ms`执行的一个事件 
                * 更新服务器状态
                * 管理客户端资源和数据库状态
                * 处理服务器接收的`SIGTERM`信号
                    * 是否关闭服务端  
        * `bgsave`讲一下
*  一个有向图用邻接矩阵表示，并且是有权图，现在问怎么判断图中有没有环
*  一个二叉树，找到二叉树中最长的一条路径
*  僵尸进程和孤儿进程
    * 孤儿进程
        * 　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被`init`进程(进程号为`1`)所收养，并由`init`进程对它们完成状态收集工作。

 
    * 僵尸进程
        * 一个进程使用`fork`创建子进程，如果子进程退出，而父进程并没有调用`wait`或`waitpid`获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程 
        * 解决方案
            * 通过信号机制
            * `fork`两次 
                * 以孤儿的方式，实际上是孙子进程在执行
                * 儿子进程创建以后就退出 
*  计算机网络`TCP`和`UDP`有什么区别，为什么迅雷下载是基于`UDP`的
    * 无连接的传输层协议，提供面向事务的简单不可靠信息传送服务
  
    * `UDP` 便于 `NAT` 穿透
        * `p2p`客户端在无论以何种有效的公网`ip`都无法访问的问题
        * `NAT`设备在此扮演的角色就是为从内网向公网发起的连接的节点分配临时的转发`session`，将来自内网的数据包的地址和端口转换为公网的地址和端口，将来自公网的数据包的地址和端口转换为内网的端口和地址
        * 建立`p2p`的`session`
            * 利用服务器来交换两个机器之间的 `endpoint`
*  每行输入`logintime，logouttime`
    *  变量取值为1天的秒数。`1--3600*24`。`10`亿行。 `logouttime - logintime`约等于3600。求每秒的**在线人数**。
*  `Linux`进程什么时候会变为**等待**
    * 等待`socket`连接、等待信号量
  
*  一个有符号的有序数组，问这些数平方之后有多少个不重复的数
*  在一个长字符串中找一个子字符串是否存在
*  `session`和`cookie`有什么差异
    * 安全性
    * 性能
    * 其他
        * 读取`Cookie`中的`SessionID`获取相对应的`Session`会话   
    * 长时`cookie`和短时`cookie`分别用在什么时候 
        * `Expires` 指定`cookie`的自动删除时间
        * 根据具体的业务场景
    * `session`不一致 
        * 跨越问题，设置可以接受 `cookie`
* `VPN`的实现原理
    *  `VPN`网关
    *  接入`VPN`就是接入了一个专有网络，使用网关进行重新包装
    *  `shadowsocks` 类似于提供一个通道
*  `http`头部字段，常用请求方法，二进制字节流是否能放进头部中
    * `HTTP/2` 采用二进制格式传输数据，而非`HTTP 1.x` 的文本格式  
        * 所有的请求都是通过多路复用的方式，一个`TCP`即可 
* 算法题（上一题变种）：给一个有序的数组（重复）和一个数`target`，找出数组中等于这个数的范围（第一个坐标和最后一个坐标
* 一个递增数组旋转后，找中位数
* `Linux`的文件系统
* 无序数组中找出连续的数中第一个缺失的数字
* `Java` 的栈会溢出吗？内存回收算法？`GCRoots`有哪些？`fullGC`产生的场景？
    * `GC`那一块有介绍 
* `CPU`有哪些组成，你怎么设计一个`CPU`？`CPU`调度算法有哪些？
    * 组成
        * 控制单元、运算单元、存储单元和时钟  
        * 控制器是计算机的控制中心：指令控制、时序控制、总线控制等
        * 算术逻辑部件、寄存器组和状态寄存器组成
        
    * 设计：
        * 生成指令系统
        * 搭建数据通路以及控制逻辑
        * 时钟信号
        
            * 优化流水线
            * 重复执行指令
            * 程序计数器的下一条指令`0x00e`也等待下一个时钟脉冲到达才能写入
    * `CPU`调度算法：
        *  同进程调度
* 信号量`PV`原语写个生产者消费者模型
    * `P(mutex);`  //进入临界区.
    * `add nextp to buffer; ` //将数据放入缓冲区
    * `V(mutex);`  //离开临界区,释放互斥信号量
* 迪杰斯特拉
    * 连个数组的实现 
* 手写字典树实现，包括了查询和插入方法
* 何判断一篇新文章中的句子在以前的文章中出现过同样的句子
* 手撕代码判断链表有环
* 手撕代码判断有环链表的环的入口
* 大量数字如何排序
* 用户态和内核态
* 阻塞队列，队列长度有限，队列为空时消费者阻塞，队列满时生产者阻塞。要求线程安全
* `Java`的范式
* 两个相交的单链表，找出交点
* 给一棵树，找出路径和为`n`的路径
* 查询平均成绩大于 `60` 分的同学的学号和平均成绩
* 一张纸横着对折`N`次，输出凹凸的序列
* 给你一个数组, 保证递增, 首先找到一个数字`k`, 然后找到最靠近这个数字`k`的`m`个数
* 奇数位升序偶数位降序，怎么实现全升序链表
* 长地址和短地址怎么实现的
* 大整数相加
* 计算`100w`以内的所有质数
* 二叉树中序遍历，写了递归式，非递归式只说了思路
* 一颗二叉树的直径，我跟他说两次`bfs`就好了
* 数据库存在不同的服务器上，为了让不同的服务器负载均衡，现在加一台服务器怎样才能让数据搬迁最少
    * 一致性`hash`引入虚节点 
* 微信发送一张图片的过程
    * 生成一条消息进行压缩，上传到服务器上
    * 服务器指定到目标地址，对于群组也是类似
    * 通知对方进行消息的接受
    * 接收方根据本地已经接收的**最后一条消息**`ID` 到服务器取最新的消息
* 复制粘贴操作系统都做了什么
    * 个人认为参考文件系统
    * 实际上就是进行一个硬拷贝 
* `cap`
    * 一致性
    * 可用性
    * 分区容错性 
* 机器人走路，有多少种做法；做完又加难度，然后在每个方格加一个权值，求最小成本是多少；然后又加难度，如果不限方向怎么做
* `tcp/ip`五层架构对应什么协议
* `jvm g1`回收器讲一下
* 有若干个整数，每次输入一个，要求每输入一个就输出当前所有输入的中位数
* 红黑树的特性
    * 所有的叶节点都是是黑色的（注意这里说叶子节点其实是上图中的 `NIL` 节点）；
    * 每个红色节点的两个子节点一定都是黑色；
    * 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点； 
* 二叉树转换成中序链表



