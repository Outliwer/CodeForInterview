## 数据库事务
* 分类

    * 扁平事务
    * 带有保存断点的扁平事务
    * 链事务
    * 嵌套事务
    * 分布式事务
* **隔离性**的实现：
    * `MVCC``（Multi-Version Concurrency Control）`：用于**提交读**的实现
        * 通过在每行记录后面保存两个隐藏的列来实现
         
            保存了行的**创建时间**和**过期时间**  （都是以**版本号**的形式存储）
        * `SELECT`：只查找当前事务版本在**创建时间**和**过期时间（可以无定义）**之间的数据
        * `INSERT、DELETE`：为新插入的每一行保存**当前系统的版本号**作为**行的版本号**
        * `UPDATE`：保存**当前系统的版本号**作为**行的版本号**以为，还会将**当前版本号**作为行的**删除标志**
    * 加锁：`gap lock、record lock、next-key lock`
    * 一致性锁定读：
        * `select .... for update. ` 写锁
        * `select .... lock in share mode` 读锁

* **原子性和持久性**的实现
    * `redo log `称为重做日志；
        * 刷新到磁盘：
            * 事务提交时
            * `log buffer`内存用到一半的时候
            * `check point` 的时候
         
    * 过程
        * `InnoDB` 存储引擎把事务写入日志缓存（`log buffer`），日志缓冲把事务刷新到事务日志：事务日志**日志组中**单个日志和磁盘扇区的**大小一样**，不需要`doublewrite`可以保证原子性。
        
        * `InnoDB` 存储引擎把事务写入缓冲池（`Buffer pool`）
        * 这样做的**原因：**
            
            对于`InnoDB`的任何修改都会在`bp`上的`page`完成，在后续会有专门的线程进行页面修改的写入：对于缓冲中数据还未刷入磁盘中，出现**非正常关闭**，因此将这些对页面的修改操作写入到`redo log `日志中，在数据库启动的时候对其进行修复。
            
            之前的**非正常关闭**，`InnoDB`只能从上一个`check point`使用重做入职来进行回滚
    * `doublewrite`技术
        *  是开辟在`tablespace`的一块连续的空间。需要将缓冲池（`Buffer pool`）中数据刷新到`page`，**首先**会放入该区域中，然后将数据刷新到磁盘中。
        
        *  数据写失败情况
            * 写入 `doublewrite`失败，则会通过事务日志进行重新读取
            * 写入磁盘失败，直接在`doublewrite`读取
    
* **一致性**的实现
    * `undo log `保证一致性
    * `undo` 实现`MVCC`,读取一行记录时,发现事务锁定,通过`undo`恢复到之前的版本,实现非锁定读取
* 日志系统
    * 物理日志
        * 新值和旧值的**信息日志** 
    * 逻辑日志
        * **有关操作**的信息日志  
    * 区别
        * 物理日志恢复的速度**快于**逻辑日志  


